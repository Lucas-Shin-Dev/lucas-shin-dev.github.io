---
layout: single
title:  "Chapter 1. 자료구조와 알고리즘 (2)"
categories: DataStructure
tag: [자료구조, C언어, 나작복]
toc: true
author_profile: false
sidebar:
    nav: "docs"
search: true #true, false
use_math: true
---

## 1.2 추상 자료형



먼저 자료형(data type)이란 용어 그대로 **데이터 종류**이다.

C언어에는 정수, 실수, 문자를 나타내는 기초적인 자료형과 다른 자료형을 묶을 수 있는 배열이나 구조체도 있다.

이외에도 스택, 큐, 리스트, 트리와 같은 새로운 자료형도 있다

![image-20230311184211916]({{site.url}}\images\2023-03-11-Review-DataStructure\image-20230311184211916.png)

***추상 자료형***(ADT: abstract data type)이란?

추상적, 수학적으로 자료형을 정의한 것이다.

ADT는 실제적인 구현으로부터 분리되어 정의된 자료형으로 데이터나 연산이 무엇(what)인지는 정의되지만 데이터나 연산을 어떻게(how) 컴퓨터 상에 구현할 것인지는 정의되지 않는다.

예를 들어서 연산을 정의할 때 연산의 이름, 매개 변수, 반환형은 정의하지만 연산을 구현하는 구체적인 코드는 주어지지 않는 것이 ADT이다.

다만 연산을 정의하는 추상적인 의사 코드는 주어질 수 있다.



## 1.3 알고리즘의 성능 분석

프로그램의 효율성은 중요하다.

첫 번째 이유는 최근 상용 프로그램의 규모가 이저넹 비해서는 엄청나게 커지고 있기 때문이다.

즉 처리해야할 자료의 양이 많기 때문에 알고리즘의 효율성이 더욱 중요하게 된다.

입력 자료의 양이 적은 경우네는 무시해도 상관없지만 자료의 양이 많아지게 되면 그 차이는 상당할 수 있다.

두 번째 이유는 사용자들은 빠른 프로그램을 선호한다는 점이다.

따라서 프로그래머는 하드웨어와는 상관없이 소프트웨어적으로 최선의 효율성을 갖는 프로그램을 제작하도록 노력하여햐 할 것이다.



### 수행시간 측정방법

효율성을 측정하는 가장 단순하고 확실한 방법은 알고리즘을 프로그래밍 언어로 작성하여 실제 컴퓨터상에서 실행시킨 다음, 그 수행 시간을 측정하는 것이다.

그러나 이 방법은 몇 가지의 문제점이 있다.

먼저 이 방법을 사용하려면 알고리즘을 구현하고 테스트하는 것이 필요하다.

알고리즘이 단순한 경우에는 쉽게 구현이 가능하지만 복잡한 경우에는 구형해야 된다는 점이 큰 부담이 될 수 있다.

또한 이 방법을 이용하여 여러 알고리즘을 비교하려면 반드시 똑같은 하드웨어를 사용하여 알고리즘들의 수행시간을 측정하여하 한다.

왜냐하면 더 좋은 성능의 컴퓨터를 이용할 경우 같은 알고리즘이더라도 더 빠른 시간에 수행될 수 있기 때문이다.

또한 사용한 소프트웨어 환경도 중요하다.

일반적인 경우, C와 같은 컴파일 언어를 사용한 경우가 베이직과 같은 인터르피트 언어를 사용한 경우보다 빠른 수행을 보인다.

또한, 실험에 사용했던 데이터가 아닌 다른 데이터에 대해서는 전혀 다른 결과가 나올 수 있다.



### 알고리즘의 복잡도 분석방법

알고리즘을 직접 구현하지 않고서도 대략적으로 효율성을 비교할 수 있게 하는 것은 알고리즘 복잡도 분석(complexity analysis)이다.

알고리즘 복잡도 분석은 구현하지 않고도 모든 입력을 고려하는 방법이고 실행 하드웨어나 소프트웨어 환경과는 관계없이 알고리즘의 효율성을 평가할 수 있다.



### 시간 복잡도 함수

알고리즘의 수행시간이 짧고 알고리즘이 필요로 하는 기억공간의 양이 적을수록 좋다라는 의미를 가진다.

알고리즘의 수행시간 분석을 ***시간 복잡도(time complextiy)***라 하고 알고리즘이 사용하는 기억공간 분석을 **공간 복잡도(space complexity)**라고 한다.

시간 복잡도는 알고리즘의 절대적인 수행 시간을 나타내는 것이 아니라 알고리즘을 이루고 있는 연산들이 몇 번이다 수행되는지 숫자로 표시한다.

연산에는 덧셈, 곱셈과 같은 **산술 연산**도 있고 **대입 연산, 비교 연산, 이동 연산**도 있다.

일반적으로 연산의 수행횟수는 고정된 숫자가 아니라 n에 대한 함수로 나타낸다.

연산의 수를 입력의 개수 $n$의 함수로 나타낸 것을 시간 복잡도 함수라 하고 $T(n)$이라고 표기한다.

![image-20230311191104699]({{site.url}}\images\2023-03-11-Review-DataStructure\image-20230311191104699.png)

![image-20230311191117393]({{site.url}}\images\2023-03-11-Review-DataStructure\image-20230311191117393.png)

![image-20230311191152454]({{site.url}}\images\2023-03-11-Review-DataStructure\image-20230311191152454.png)

같은 결론을 도출하더라도 알고리즘에 따라 n이 커질수록 연산의 차이는 커지게 된다.

따라서 연산의 개수를 이용하여 알고리즘들을 비교하고 비교한 결과를 바탕으로 가장 효율적인 알고리즘을 선택할 수 있다.



### 빅오 표기법

일반적으로 입력의 개수 n과 시간 복잡도 함수 $\T(n)\$의 관계는 상당히 복잡할 수 있다.

$T(n) = n^2 + n + 1$ 이라고 가정하자.

$n^2$이 전체 중 대부분을 차지하고 나머지 $n$과 1이 아주 작은 영향을 줌으로 차수가 가장 큰 항만 고려해도 충분하다.

시간 복잡도 함수에서 불필요한 정보를 제거하여 알고리즘 분석을 쉽게 할 목적으로 시간 복잡도를 표시하는 방법을 **빅오 표기법**이라고 한다.

즉 알고리즘의 시간복잡도가 $O(n^2)$이라고 한다.

$O(n)%$은 "Big O of n"이라고 읽는다.

빅오 표기법은 $n$의 값에 따른 함수의 상한값을 나타내는 방법이다.

수학적으로는 다음과 같이 정의된다.

![image-20230311195527470]({{site.url}}\images\2023-03-11-Review-DataStructure\image-20230311195527470.png)

다음은 빅오 표기법에 의한 알고리즘의 수행시간을 비교한 것이다.

오른쪽으로 갈수록 연산의 수(수행 시간)이 기하급수적으로 증가한다.

![image-20230311195851000]({{site.url}}\images\2023-03-11-Review-DataStructure\image-20230311195851000.png)

![image-20230311201410852]({{site.url}}\images\2023-03-11-Review-DataStructure\image-20230311201410852.png)

### 빅오 표기법 이외의 표기법

빅오 표기법은 상한을 표기한 것이므로 여러 개가 존재할 수 있다.

그러나 빅오 표기법이 최소 차수 함수로 표기되었을 경우만 의미가 있다.

따라서 이와 같은 문제를 보완하기 위하여 빅오메가오 빅세타 표기법이 있다.

**빅오메가 표기법**는 어떤 함수의 하한을 표기하는 방법이다.

수학적으로는 다음과 같이 정의된다.

![image-20230311200150339]({{site.url}}\images\2023-03-11-Review-DataStructure\image-20230311200150339.png)

**빅세타 표기법**는 동일한 함수로 상한과 하한을 표기하는 방법이다.

수학적으로는 다음과 같이 정의된다.

![image-20230311200252381]({{site.url}}\images\2023-03-11-Review-DataStructure\image-20230311200252381.png)



3개의 표기법 중에서 가장 정밀한 것은 빅세타이다.

그러나 통상적으로는 빅오 표기법을 많이 사용한다.



### 최선, 평균, 최악의 경우

똑같은 알고리즘도 주어진 입력의 집합에 따라 다른 수행 시간을 보일 수 있다.

알고리즘의 효율성은 주어지는 자료집합에 따라 다음의 3가지 경우로 나누어서 평가할 수 있다.

최악의 경우(worst case)는 자료집합 중에서 알고리즘의 수행 시간이 가장 오래 걸리는 경우이다.

최선의 경우(best case)는 수행 시간이 가장 적은 경우를 의미한다.

평균적인 경우(average case)는 알고리즘의 모든 입력을 고려하고 각 입력이 발생하는 확률을 고려하여 평균적인 수행 시간을 의미한다.



3가지 경우 중 평균적인 수행 시간이 가장 좋아 보인다.

그러나 많은 자료 집합에 대하여 알고리즘을 적용시켜서 평균값을 계산해야 하기 때문에 평균 수행 시간을 구하기 상당히 힘들다.

따라서 최악의 경우의 수행 시간이 알고리즘의 시간 복잡도 척도로 많이 쓰인다.

어떤 함수의 상한(최악의 경우)을 표기하는 **빅오 표기법**이 많이 사용되는 이유이다.

